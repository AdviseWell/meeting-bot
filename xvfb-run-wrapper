#!/bin/bash

# Forward SIGTERM to child processes
trap 'echo "sending SIGABRT to child"; kill -SIGABRT "$child" 2>/dev/null; kill -TERM "$pulse_pid" 2>/dev/null' SIGTERM SIGINT

# Set up writable XDG directories for Chrome/Chromium
# This prevents the "chrome_crashpad_handler: --database is required" crash
export XDG_CONFIG_HOME=/tmp/chrome/config
export XDG_CACHE_HOME=/tmp/chrome/cache
mkdir -p "$XDG_CONFIG_HOME" "$XDG_CACHE_HOME"
echo "XDG directories configured: $XDG_CONFIG_HOME, $XDG_CACHE_HOME"

# Set up separate runtime directory for PulseAudio (must be owned by current user)
export XDG_RUNTIME_DIR=/tmp/pulse-runtime
mkdir -p "$XDG_RUNTIME_DIR"
chmod 700 "$XDG_RUNTIME_DIR"
echo "PulseAudio runtime directory: $XDG_RUNTIME_DIR"

# Set PulseAudio environment variables for Chrome
export PULSE_SERVER=unix:/tmp/pulse-runtime/pulse/native
export PULSE_COOKIE=/tmp/pulse-runtime/pulse/cookie
echo "PulseAudio environment variables set for Chrome: PULSE_SERVER=$PULSE_SERVER"

# Start PulseAudio in daemon mode with modules pre-loaded (container-friendly startup)
echo "Starting PulseAudio..."
pulseaudio --daemonize --system=false --exit-idle-time=-1 --log-target=stderr \
    --use-pid-file=false --disallow-exit --disallow-module-loading=false \
    --load="module-null-sink sink_name=dummy_output sink_properties=device.description=Virtual_Dummy_Output" \
    --load="module-virtual-source source_name=chrome_input master=dummy_output.monitor source_properties=device.description=Chrome_Audio_Input" &
pulse_pid=$!

# Wait for PulseAudio to be ready (check if server is accepting connections)
echo "Waiting for PulseAudio to be ready..."
for i in {1..15}; do
    if pactl info &>/dev/null; then
        echo "PulseAudio is ready"
        break
    fi
    echo "Waiting for PulseAudio... attempt $i/15"
    sleep 1
done

# Verify PulseAudio is actually ready
if ! pactl info &>/dev/null; then
    echo "ERROR: PulseAudio failed to start properly"
    ps aux | grep pulse
    journalctl -n 20 --no-pager 2>/dev/null || echo "No journalctl available"
    exit 1
fi

# Set default sink and source (modules already loaded above)
echo "Setting default audio devices..."
pactl set-default-sink dummy_output
pactl set-default-source chrome_input

# Set volume to 100% and unmute (critical - sinks may start muted or at 0%)
echo "Setting audio volume to 100%..."
pactl set-sink-volume dummy_output 100%
pactl set-sink-mute dummy_output 0
pactl set-source-volume chrome_input 100%
pactl set-source-mute chrome_input 0

# Verify the sink and source were created
if ! pactl list sinks | grep -q "dummy_output"; then
    echo "ERROR: Failed to create dummy_output sink"
    exit 1
fi

if ! pactl list sources | grep -q "chrome_input"; then
    echo "ERROR: Failed to create chrome_input source"
    exit 1
fi

echo "PulseAudio audio levels set to 100% (unmuted)"

echo "PulseAudio setup complete"

# Start Xvfb
echo "Starting Xvfb..."
Xvfb :99 -screen 0 1280x720x24 &
xvfb_pid=$!

# Wait for Xvfb to start
sleep 2

# Start your application
echo "Starting application..."
DISPLAY=:99 "$@" &
child=$!

# Wait for the child process to finish. have to use these both commands
wait "$child"
tail --pid="$child" -f /dev/null
child_exit_code=$?

# Cleanup processes
echo "Cleaning up processes..."
kill -TERM "$xvfb_pid" 2>/dev/null
wait "$xvfb_pid" 2>/dev/null

pulseaudio --kill 2>/dev/null
kill -TERM "$pulse_pid" 2>/dev/null
wait "$pulse_pid" 2>/dev/null

# Exit with the application's exit code
exit "$child_exit_code"
